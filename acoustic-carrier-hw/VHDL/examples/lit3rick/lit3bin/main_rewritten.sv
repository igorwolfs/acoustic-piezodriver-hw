// Code generated by Icestudio 0.8.0

`default_nettype none

//---- Top entity
module main (
 input [9:0] adc_data_in,
 input reset,
 input fpga_reset,
 input trigger_in,
 input ice_cs,
 input hw_trigger,
 input spi_sclk,
 input spi_mosi,
 output dac_cs,
 output adc_clock,
 output dac_sclk,
 output dac_mosi,
 output [2:0] rgb_led,
 output spi_miso,
 output enable_adc_clk,
 output hv_enable,
 output high_voltage_pulse,
 output low_voltage_pulse,
 output damping_pulse,
 output hilo_select
);
 wire [0:12] adc_write_addr;
 wire [0:7] spi_to_controller;
 wire spi_strobe;
 wire adc_trigger;
 wire [0:12] adc_read_addr;
 wire [0:15] dac_data;
 wire dac_valid;
 wire [0:7] controller_to_spi;
 wire capture_hilo;
 wire reset_signal;
 wire reset_signal2;
 wire reset_signal3;
 wire spi_sclk;
 wire spi_mosi;
 wire [0:9] adc_data_bus;
 wire reset_signal6;
 wire reset_signal7;
 wire reset_signal8;
 wire reset_signal9;
 wire [0:2] led_status;
 wire reset_signal10;
 wire reset_signal11;
 wire reset_signal12;
 wire reset_signal13;
 wire reset_signal14;
 wire reset_signal15;
 wire reset_signal16;
 wire reset_signal17;
 wire reset_signal18;
 wire [0:15] adc_read_data;
 assign reset_signal3 = ice_cs;
 assign spi_sclk = spi_sclk;
 assign spi_mosi = spi_mosi;
 assign spi_miso = reset_signal6;
 assign reset_signal7 = fpga_reset;
 assign reset_signal8 = trigger_in;
 assign reset_signal9 = hw_trigger;
 assign adc_data_bus = adc_data_in;
 assign dac_cs = reset_signal10;
 assign dac_sclk = reset_signal11;
 assign enable_adc_clk = reset_signal12;
 assign rgb_led = led_status;
 assign dac_mosi = reset_signal13;
 assign adc_clock = reset_signal14;
 assign hilo_select = reset_signal15;
 assign damping_pulse = reset_signal16;
 assign low_voltage_pulse = reset_signal17;
 assign high_voltage_pulse = reset_signal18;
 assign hilo_select = capture_hilo;
 assign reset_signal7 = reset;
 assign reset_signal8 = fpga_reset;
 assign reset_signal8 = reset_signal7;
 assign reset_signal9 = fpga_reset;
 assign reset_signal9 = reset_signal7;
 assign reset_signal9 = reset_signal8;
 assign reset_signal10 = reset_signal6;
 assign reset_signal11 = reset_signal6;
 assign reset_signal11 = reset_signal10;
 assign reset_signal12 = reset_signal6;
 assign reset_signal12 = reset_signal10;
 assign reset_signal12 = reset_signal11;
 ADC_Capture_Module adc_capture (
  .adc_wr_addr_out(adc_write_addr),
  .adc_trig_in(adc_trigger),
  .adc_rd_addr_in(adc_read_addr),
  .hilo_select_out(capture_hilo),
  .trigger_in(reset_signal8),
  .hw_trigger_in(reset_signal9),
  .adc_data_in(adc_data_bus),
  .hv_enable_out(hv_enable),
  .rgb_led_out(led_status),
  .adc_clk_out(adc_clock),
  .ea_clk_out(enable_adc_clk),
  .reset_in(reset_signal9),
  .dclk_in(reset_signal10),
  .adc_rd_data_out(adc_read_data)
 );
 SPI_Interface_Module spi_interface (
  .from_spi_out(spi_to_controller),
  .spi_strb_out(spi_strobe),
  .to_spi_in(controller_to_spi),
  .ice_cs_in(reset_signal3),
  .f_sclk_in(spi_sclk),
  .f_mosi_in(spi_mosi),
  .f_miso_out(reset_signal6),
  .rst_in(reset_signal7)
 );
 DAC_Output_Module dac_output (
  .dac_data_in(dac_data),
  .dac_valid_in(dac_valid),
  .dac_cs_out(reset_signal10),
  .dac_sclk_out(reset_signal11),
  .dac_mosi_out(reset_signal12),
  .dclk_in(reset_signal6),
  .rst_in(reset_signal7)
 );
 Pulse_Generator_Module pulse_generator (
  .phv_out(high_voltage_pulse),
  .pnhv_out(low_voltage_pulse),
  .pdamp_out(damping_pulse),
  .dclk_in(reset_signal12),
  .adc_wr_addr_in(adc_write_addr)
 );
 Controller_Module controller (
  .from_spi_in(spi_to_controller),
  .spi_strb_in(spi_strobe),
  .adc_trig_out(adc_trigger),
  .adc_rd_addr_out(adc_read_addr),
  .dac_data_out(dac_data),
  .dac_valid_out(dac_valid),
  .to_spi_out(controller_to_spi),
  .hilo_out(capture_hilo),
  .rst_in(reset_signal8),
  .dclk_in(reset_signal11),
  .adc_rd_data_in(adc_read_data)
 );
endmodule

/*-------------------------------------------------*/
/*--   ADC Capture Module                        --*/
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Handles ADC data acquisition and storage    --*/
/*-------------------------------------------------*/
//---- Top entity
module ADC_Capture_Module (
 input reset_in,
 input dclk_in,
 input [9:0] adc_data_in,
 input trigger_in,
 input hw_trigger_in,
 input adc_trig_in,
 input [12:0] adc_rd_addr_in,
 input hilo_select_out,
 output ea_clk_out,
 output adc_clk_out,
 output [2:0] rgb_led_out,
 output hv_enable_out,
 output [15:0] adc_rd_data_out,
 output [12:0] adc_wr_addr_out
);
 wire dclk;
 wire [0:9] adc_data;
 wire trigger;
 wire hw_trigger;
 wire [0:2] rgb_led;
 wire hv_enable;
 wire adc_clk;
 wire ea_clk;
 wire hilo_select;
 wire reset;
 wire adc_trigger;
 wire [0:12] adc_rd_addr;
 wire [0:15] adc_rd_data;
 wire [0:12] adc_wr_addr;
 assign dclk = dclk_in;
 assign adc_data = adc_data_in;
 assign trigger = trigger_in;
 assign hw_trigger = hw_trigger_in;
 assign rgb_led_out = rgb_led;
 assign ea_clk_out = ea_clk;
 assign adc_clk_out = adc_clk;
 assign hv_enable_out = hv_enable;
 assign hilo_select = hilo_select_out;
 assign reset = reset_in;
 assign adc_trigger = adc_trig_in;
 assign adc_rd_addr = adc_rd_addr_in;
 assign adc_rd_data_out = adc_rd_data;
 assign adc_wr_addr_out = adc_wr_addr;
 ADC_Capture_Module_vf8ce5e adc_capture_impl (
  .DCLK(dclk),
  .ADC_DATA(adc_data),
  .TOP_T1(trigger),
  .TOP_T2(hw_trigger),
  .RGB(rgb_led),
  .HV_EN(hv_enable),
  .ADC_CLK(adc_clk),
  .EA_CLK(ea_clk),
  .HILO(hilo_select),
  .RST(reset),
  .adc_trig(adc_trigger),
  .adc_rd_addr(adc_rd_addr),
  .adc_rd_data(adc_rd_data),
  .adc_wr_addr(adc_wr_addr)
 );
endmodule

/*-------------------------------------------------*/
/*--   ADC Capture Implementation                --*/
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Captures and stores ADC data in SRAM        --*/
/*-------------------------------------------------*/

module ADC_Capture_Module_vf8ce5e (
 input RST,
 input DCLK,
 input [9:0] ADC_DATA,
 input TOP_T1,
 input TOP_T2,
 input adc_trig,
 input [12:0] adc_rd_addr,
 input HILO,
 output HV_EN,
 output ADC_CLK,
 output [2:0] RGB,
 output EA_CLK,
 output [15:0] adc_rd_data, // 10-bit ADC DATA READ at DCLK speed
 output [12:0] adc_wr_addr
);
  reg         adc_wr_en;
  wire [15:0] adc_wr_data;
  reg  [12:0] adc_wr_addr;
  
  defparam OSCInst0.CLKHF_DIV = "0b00";  // 48MHz internal Clock
  SB_HFOSC OSCInst0 ( .CLKHFEN(1'b1), .CLKHFPU(1'b1),.CLKHF(ADC_CLK) 
  ) /* synthesis ROUTE_THROUGH_FABRIC= [0] */;
  
  // @64MHz 8192 Clocks = 128us / @48MHz 8192 Clocks = 170.667us
  always@(posedge DCLK)begin 
   if(RST) begin // PWM_CLK pin
    adc_wr_addr <= 13'h1fff;
    adc_wr_en   <= 0;
   end else if(adc_trig) begin
    adc_wr_addr <= 0;
    adc_wr_en   <= 1;
   end else if(adc_wr_addr!=13'h1fff) begin
    adc_wr_addr <= adc_wr_addr + 1;
   end else if(adc_wr_addr==13'h1fff) begin
    adc_wr_en   <= 0;
   end
  end
  
  // SRAM for ADC DATA Writing and Reading
  assign adc_wr_data = {TOP_T2,TOP_T1,HV_EN,HILO,ADC_DATA,2'd0};
  wire [13:0] ADDRESS;
  assign ADDRESS = {1'b0,(adc_wr_en)?adc_wr_addr:adc_rd_addr};

  // SRAM for storing captured data - 8K samples capacity
  SB_SPRAM256KA ram(
 		.DATAOUT(adc_rd_data),
 		.ADDRESS(ADDRESS),
 		.DATAIN(adc_wr_data),
 		.MASKWREN(4'b1111),
 		.WREN(adc_wr_en),
 		.CHIPSELECT(1'b1),
 		.CLOCK(DCLK),
 		.STANDBY(1'b0),
 		.SLEEP(1'b0),
 		.POWEROFF(1'b1)
  );
  
  // Driving output LED for status monitoring
  // Red  -> Capturing Data or Busy for SPI_Read
  // Green-> READY for Capture or Read
  // Blue -> Blinks during DAC Configuration
  SB_RGBA_DRV #(
             .CURRENT_MODE ("0b0"),
             .RGB0_CURRENT ("0b111111"),
             .RGB1_CURRENT ("0b111111"),
             .RGB2_CURRENT ("0b111111")
  ) RGB_driver (
             .CURREN   (1'b1),       // I
             .RGBLEDEN (1'b1),       // I
             .RGB0PWM  (~adc_wr_en), // I
             .RGB1PWM  (adc_wr_en),  // I
             .RGB2PWM  (1'b1),       // I
             .RGB2     (RGB[2]),     // O
             .RGB1     (RGB[1]),     // O
             .RGB0     (RGB[0])      // O
  );
  assign EA_CLK = adc_wr_en; 
  assign HV_EN  = adc_wr_en;
 
endmodule

/*-------------------------------------------------*/
/*--   SPI Interface Module                      --*/
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Handles SPI communication with host         --*/
/*-------------------------------------------------*/
//---- Top entity
module SPI_Interface_Module (
 input rst_in,
 input ice_cs_in,
 input f_sclk_in,
 input f_mosi_in,
 input [7:0] to_spi_in,
 output f_miso_out,
 output [7:0] from_spi_out,
 output spi_strb_out
);
 wire ice_cs;
 wire f_miso;
 wire f_mosi;
 wire f_sclk;
 wire rst;
 wire [0:7] to_spi;
 wire [0:7] from_spi;
 wire spi_strb;
 assign ice_cs = ice_cs_in;
 assign f_miso_out = f_miso;
 assign f_mosi = f_mosi_in;
 assign f_sclk = f_sclk_in;
 assign rst = rst_in;
 assign to_spi = to_spi_in;
 assign from_spi_out = from_spi;
 assign spi_strb_out = spi_strb;
 SPI_Interface_Module_v69b127 spi_interface_impl (
  .ICE_CS(ice_cs),
  .F_MISO(f_miso),
  .F_MOSI(f_mosi),
  .F_SCLK(f_sclk),
  .RST(rst),
  .to_spi(to_spi),
  .from_spi(from_spi),
  .spi_strb(spi_strb)
 );
endmodule

/*-------------------------------------------------*/
/*--   SPI Interface Implementation              --*/
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Handles SPI protocol details               --*/
/*-------------------------------------------------*/

module SPI_Interface_Module_v69b127 (
 input RST,
 input ICE_CS,
 input F_SCLK,
 input F_MOSI,
 input [7:0] to_spi,
 output F_MISO,
 output [7:0] from_spi,
 output spi_strb
);
 // SPI MODE 3: write(F_MISO)@negedge,read(F_MOSI)@posedge
 reg spi_strb;
 reg [7:0] from_spi,treg,rreg;
 reg [3:0] nb;
 assign F_MISO = (!ICE_CS) ? treg[7] : 1'bz; // 1:send data,0: TRI-STATE
 always @(posedge F_SCLK or posedge RST) begin
     if (RST) begin
 		rreg	 = 8'h00;
 		from_spi = 8'h00;
 		spi_strb = 0;
 		nb		 = 0;
 	end else if (!ICE_CS) begin
 		rreg     = {rreg[6:0],F_MOSI}; // read from F_MISO
 		nb       = nb+1;
 		if(nb!=8)
             spi_strb = 0;
 		else begin
             from_spi = rreg;
             spi_strb = 1;
             nb       = 0;
 		end
 	end // !ICE_CS
 end
 always @(negedge F_SCLK or posedge RST) begin
     if (RST) begin
 		treg     = 8'hFF;
 	end else if (!ICE_CS) begin
 		treg     = (nb==0) ? to_spi : {treg[6:0],1'b1}; // send to F_MISO
     end // !ICE_CS
 end
 
endmodule

/*-------------------------------------------------*/
/*--   DAC Output Module                         --*/
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Drives the DAC output signals               --*/
/*-------------------------------------------------*/
//---- Top entity
module DAC_Output_Module (
 input dclk_in,
 input rst_in,
 input [15:0] dac_data_in,
 input dac_valid_in,
 output dac_cs_out,
 output dac_sclk_out,
 output dac_mosi_out
);
 wire dclk;
 wire rst;
 wire [0:15] dac_data;
 wire dac_valid;
 wire dac_cs;
 wire dac_sclk;
 wire dac_mosi;
 assign dclk = dclk_in;
 assign rst = rst_in;
 assign dac_data = dac_data_in;
 assign dac_valid = dac_valid_in;
 assign dac_cs_out = dac_cs;
 assign dac_sclk_out = dac_sclk;
 assign dac_mosi_out = dac_mosi;
 DAC_Output_Module_v3f5e74 dac_output_impl (
  .DCLK(dclk),
  .rst(rst),
  .dac_data(dac_data),
  .dac_valid(dac_valid),
  .DAC_CS(dac_cs),
  .DAC_SCLK(dac_sclk),
  .DAC_MOSI(dac_mosi)
 );
endmodule

/*-------------------------------------------------*/
/*--   DAC Output Implementation                 --*/
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Manages SPI protocol for DAC                --*/
/*-------------------------------------------------*/

module DAC_Output_Module_v3f5e74 (
 input DCLK,
 input rst,
 input [15:0] dac_data,
 input dac_valid,
 output DAC_CS,
 output DAC_SCLK,
 output DAC_MOSI
);
 localparam max_div_cnt = 10;
 reg data_valid_z, work, sck_int;
 reg [3:0] state;   reg [7:0]  clk_div_cnt;
 reg [4:0] bit_cnt; reg [15:0] shift_reg;
 assign DAC_SCLK       = sck_int && !DAC_CS;
 assign DAC_CS         = (bit_cnt < 16) ? ~work : 1;
 assign DAC_MOSI       = shift_reg[15];
 always @(posedge DCLK or posedge rst) begin
 	if (rst == 1) begin
 		work<=0; data_valid_z<=0; clk_div_cnt<=0; bit_cnt<=0; sck_int<=0;
 	end else begin
 		data_valid_z <= dac_valid;
 		if (work == 0)
 			sck_int <= 0;
 		else if (clk_div_cnt == max_div_cnt) // clk_div_cnt_ov
 			sck_int <= ~sck_int;
 		if ((bit_cnt == 19) && (clk_div_cnt == max_div_cnt)) // end_work
 			work <= 0;
 		else if (dac_valid == 1 && data_valid_z == 0)
 			work <= 1;
 		if (dac_valid == 1 && data_valid_z == 0) begin
 			shift_reg <= dac_data;
 			bit_cnt <= 0;
 		end else if ((clk_div_cnt == max_div_cnt) && sck_int == 1) begin
 			shift_reg <= {shift_reg[14:0], 1'b0};
 			bit_cnt <= bit_cnt + 1;
 		end
 		if((clk_div_cnt == max_div_cnt) || work == 0) clk_div_cnt <=  0;
 		else clk_div_cnt <= clk_div_cnt + 1;
 	end
 end
 
endmodule

/*-------------------------------------------------*/
/*--   Pulse Generator Module                    --*/
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Generates timing pulses for the system      --*/
/*-------------------------------------------------*/
//---- Top entity
module Pulse_Generator_Module (
 input dclk_in,
 input [12:0] adc_wr_addr_in,
 output phv_out,
 output pnhv_out,
 output pdamp_out
);
 wire dclk;
 wire pdamp;
 wire phv;
 wire pnhv;
 wire [0:12] adc_wr_addr;
 assign dclk = dclk_in;
 assign pdamp_out = pdamp;
 assign phv_out = phv;
 assign pnhv_out = pnhv;
 assign adc_wr_addr = adc_wr_addr_in;
 Pulse_Generator_Module_vf8ce5e pulse_generator_impl (
  .DCLK(dclk),
  .Pdamp(pdamp),
  .PHV(phv),
  .PnHV(pnhv),
  .adc_wr_addr(adc_wr_addr)
 );
endmodule

/*-------------------------------------------------*/
/*--   Pulse Generator Implementation            --*/
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Generates specific timing pulses            --*/
/*-------------------------------------------------*/

module Pulse_Generator_Module_vf8ce5e (
 input DCLK,
 input [12:0] adc_wr_addr,
 output PHV,
 output PnHV,
 output Pdamp
);
 reg PHV,PnHV,Pdamp;
  // Pulsar signals generation
  // @64MHz 8 clocks = 125ns; 32 clocks = 500ns; 64 clocks = 1000ns;
  // @48MHz 6 clocks = 125ns; 24 clocks = 500ns; 48 clocks = 1000ns;
  always@(posedge DCLK)begin
   // PHV   <= (adc_wr_addr>=32 && adc_wr_addr<40 ) ? 1'b1 : 1'b0;
   // PnHV  <= (adc_wr_addr>=48 && adc_wr_addr<56 ) ? 1'b1 : 1'b0;
   // Pdamp <= (adc_wr_addr>=64 && adc_wr_addr<128) ? 1'b1 : 1'b0;
   PHV   <= (adc_wr_addr>=24 && adc_wr_addr<30 ) ? 1'b1 : 1'b0;
   PnHV  <= (adc_wr_addr>=36 && adc_wr_addr<42 ) ? 1'b1 : 1'b0;
   Pdamp <= (adc_wr_addr>=48 && adc_wr_addr<96 ) ? 1'b1 : 1'b0;
  end
  
endmodule

/*-------------------------------------------------*/
/*--   Controller Module                         --*/
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Main control logic for system coordination  --*/
/*-------------------------------------------------*/
//---- Top entity
module Controller_Module (
 input dclk_in,
 input rst_in,
 input [7:0] from_spi_in,
 input spi_strb_in,
 input [15:0] adc_rd_data_in,
 output [15:0] dac_data_out,
 output dac_valid_out,
 output adc_trig_out,
 output [12:0] adc_rd_addr_out,
 output hilo_out,
 output [7:0] to_spi_out
);
 wire rst;
 wire dclk;
 wire hilo;
 wire [0:7] from_spi;
 wire spi_strb;
 wire [0:7] to_spi;
 wire adc_trig;
 wire [0:15] dac_data;
 wire dac_valid;
 wire [0:12] adc_rd_addr;
 wire [0:15] adc_rd_data;
 assign rst = rst_in;
 assign dclk = dclk_in;
 assign hilo_out = hilo;
 assign from_spi = from_spi_in;
 assign spi_strb = spi_strb_in;
 assign to_spi_out = to_spi;
 assign adc_trig_out = adc_trig;
 assign dac_data_out = dac_data;
 assign dac_valid_out = dac_valid;
 assign adc_rd_addr_out = adc_rd_addr;
 assign adc_rd_data = adc_rd_data_in;

 Controller_Module_vf8ce5e controller_impl (
  .RST(rst),
  .DCLK(dclk),
  .HILO(hilo),
  .from_spi(from_spi),
  .spi_strb(spi_strb),
  .to_spi(to_spi),
  .adc_trig(adc_trig),
  .dac_data(dac_data),
  .dac_valid(dac_valid),
  .adc_rd_addr(adc_rd_addr),
  .adc_rd_data(adc_rd_data)
 );
endmodule

/*-------------------------------------------------*/
/*--   Controller Implementation                 --*/
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Core control logic implementation           --*/
/*-------------------------------------------------*/

module Controller_Module_vf8ce5e (
 input DCLK,
 input RST,
 input [7:0] from_spi,
 input spi_strb,
 input [15:0] adc_rd_data,
 output [15:0] dac_data,
 output dac_valid,
 output adc_trig,
 output [12:0] adc_rd_addr,
 output HILO,
 output [7:0] to_spi
);
  reg         adc_trig;
  reg  [15:0] dac_data;
  reg         dac_valid;
  reg         HILO;
  reg  [12:0] adc_rd_addr;
  reg  [15:0] spi_data;
  reg  [13:0] spi_data_active;
  reg         spi_strb_adc_clk;
  reg         spi_strb_adc_clk_z;
  reg         spi_strb_adc_clk_zz;
  reg         spi_strb_adc_clk_zzz;
  reg         spi_strb_adc_clk_zzzz;
  reg         spi_data_byte;
  reg  [1:0]  spi_mode;
  assign to_spi = (spi_data_byte == 0) ? adc_rd_data[7:0] : adc_rd_data[15:8];
  always @(posedge DCLK or posedge RST) begin // Clock domain crossing Logic
 	if (RST) begin
 		spi_data <= 0;
 		spi_strb_adc_clk <= 0;
 		spi_strb_adc_clk_z <= 0;
 		spi_strb_adc_clk_zz <= 0;
 		spi_strb_adc_clk_zzz <= 0;
 		spi_strb_adc_clk_zzzz <= 0;
 		spi_data_byte <= 0;
 	end else begin
 		spi_strb_adc_clk_zzzz <= spi_strb_adc
	end
end
endmodule